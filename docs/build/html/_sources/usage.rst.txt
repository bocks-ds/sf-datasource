Usage
=====

Please see the SDK documentaiton for your favored language for more information about how to include *DataSource* in your codebase.

If you wish to test a particular *DataSource* API directly, you may go to the base url for the application. For example, if you go to https://sfdatasource.com you will be presented with a user interface provided by ApolloServer.

The UI provides several resources to you for testing.

On the right hand side of the UI is a fold-out section for "schema" and "docs". These are auto-generated by ApolloServer and are intended to show you the core capabilities of the application. Additionally, the input section on the right side of the page features autofill suggestions and syntax checking with suggestions for how to correct syntax errors. Finally, if you submit a query with an error, the response message will usually contain a suggested correction.

*****

Basic Query
***********

When querying data, you may wish to get a complete list of all entries in a table. To do so you *must* specify both the table name you are querying, and the content you wish to retrieve. You can see more about the available content in the "Structures" section of this documentation, or in the 'schema' section of the UI that corresponds to the object that is returned by your query.

For example, if we look at the UI 'docs' section for the :code:`armor` entry, we will see that it returns an object called :code:`Armor`, while the :code:`weapons` entry returns an object called :code:`Weapon`. We can then click over to the UI 'schema' and find the :code:`Armor` or :code:`Weapon` entry to see what data is available for that object.

Example of a full-list query to fetch only the name from all entries:

.. code-block::

    {
        armor {
            name
        }
    }

All queries to the API must be contained in a top-level object, represented by an open bracket at the beginning and a close bracket at the end.

Your query may include multiple queries within it. To do that, we can simply extend the previous example:

.. code-block::

    {
        armor {
            name
        }
        weapons {
            name
        }
    }

This will give us a list of names from all 'armor' rows, and then a second entry with the same from 'weapons'.

By adding another entry below 'name', we can get more data from the column. Available columns may be seen in the UI 'schema' or in the documentation here under "Structures".

For example:

.. code-block::

    {
        armor {
            name
            type
            level
            price
        }
    }

This will return the same list as querying :code:`{armor {name}}`, but with additional content brought back for each row.

Example return (snippet):
.. code-block::

  "data": {
    "armor": [
      {
        "name": "Estex suit I",
        "type": 0,
        "level": 1,
        "price": 410
      },
    ...
    }

*****

Refined Query
*************

You may wish to refine your query to get a specific row or select rows. To do so, we will harness the avaliable resolvers that are listed in the UI 'docs' section.

If you look at the UI 'docs' section, you will see that some table queries have a long list of available resolvers. Here is a breakdown of what you might see.

These resolvers are placed in parentheses following the name of the table you are querying.

Integer
-------

**Resolvers:**

- :code:`*_is`
- :code:`*_like`

Example column: :code:`price`

- :code:`price_min` - Get any row where the :code:`price` value is *greater* than or equal to this value.
- :code:`price_max` - Get any row where the :code:`price` value is *less* than or equal to this value.
- :code:`price_equals` Get any row where the :code:`price` value is *equal* to this value.

Example:

.. code-block::

    {
        armor(price_max:1000) {
            name
            price
        } # returns all rows where price is 1000 or lower
    }

String
------

**Resolvers:**

- :code:`*_is`
- :code:`*_like`

Example column: :code:`name`

- :code:`name_is` - Get any row where the name *exactly* matches this value. Case sensitive.
- :code:`name_like` - Get any row that contains this string. Not case sensitive. If spaces are present, looks for both words in any order.

.. code-block::

    {
        armor(name_is:"Second skin") {
            name
        } # returns one entry, if found
        armor(name_like:"skin second") {
            name
        } # returns same entry as above, along with any other rows that contain these two words in the name
    }


ID
--

Resolvers: 
- :code:`id`
- :code:`effect_ranges_id`

Avaliable resolvers:
- id - Unique value for each row on the table. We do not use UUID/GUID values, these are always incremented integers.
- effect_ranges_id - This is an integer that matches the :code:`id` value on the :code:`effect_ranges` table.

.. code-block::

    {
        armor(id:1) {
            name
        } 
    }

.. code-block::

    {
        spells(effect_ranges_id:1) {
            name
            effect_ranges
        } # returns a list of spells whose effect_ranges_id is 1
    }

*****

Nested Queries
**************

In some circumstances, a query will allow for additional query resolvers to be nested within it. This is represented in the UI docs by a column having a type that is not 'ID', 'String', or 'Int', but instead the type is the name of another object.


Foreign Keys (direct relationships)
-----------------------------------

In the example above for **IDs**, we see that spells has a value for :code:`effect_ranges_id`. However, that value is not available as a column when querying :code:`spells`.

The following will result in an error:

.. code-block::

    {
    spells {
        name
        effect_ranges_id
        }
    } # Message: Cannot query field "effect_ranges_id" on type "Spell". Did you mean "effect_ranges"?

Thankfully the response message gives us a suggestion here. While the table has a *column* of :code:`effect_ranges_id`, it has a *resolver* of :code:`effect_ranges`. This is a bit of a gritty explanation, but what we need to know here is as follows...

All foreign-keys are resolved into nested objects, rather than returning their FK ID value. If the column here has a value of ``1``, our API will fetch the first entry from ``effect_ranges`` and nest that object here.

As such, in order to see the literal value for :code:`effect_ranges_id` we would need to do the following. (But lets also ask for the 'name' while we're at it!)

.. code-block::

    {
    spells {
        name
        effect_ranges {
            id
            name
            }
        }
    }

The above query will return the following content (snippet):

.. code-block::

    "data": {
        "spells": [
        {
            "name": "Animate Dead",
            "effect_ranges": {
                "id": "2",
                "name": "touch"
            } # Although the name is plural here (matching its table name), this will only ever get one object
        },
        ...
    }

Supporting Tables (indirect relationships)
------------------------------------------

Unlike foreign keys, which are present in the data table, some relatioships come from information in other tables. As noted in the "Structures" and "Relationships" sections of this documentation, we can still access those relationships in our standard query.

For example, *sfdatasource* :code:`classes` have a many-to-many relationship in their "class_features", where classes have many feats, and some feats are referenced by many classes.

In this example, the :code:`class_features` data table defines that relationship, and our :code:`Class` query can access that information.

As such, the :code:`class_features` response will be a list of :code:`Feat` objects.

Example query:

.. code-block::

    {
        classes {
        name
        class_features {
            name
            }
        }
    }

Response:

.. code-block::

    {
        "data": {
            "classes": [
            {
                "name": "Envoy",
                "class_features": [
                {
                    "name": "Envoy Improvisation"
                },
                {
                    "name": "Expertise"
                },
                ...
                ]
            }
            ...
            ]
        }
    }
